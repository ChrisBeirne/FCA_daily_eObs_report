---
title: "Osa Conservation: Tracker Checker"

author:
  - Chris Beirne


site: bookdown::test-bookdown
output: bookdown::gitbook
documentclass: book
biblio-style: apalike
link-citations: yes
---

# Tracker status checker

This document summarize the movement locations for all active collars within Osa Conservation's `OC Vultures` project. 

```{r, echo=F, message=F, include=F}
library(move)
library(dplyr)
library(leaflet)
library(sf)
library(viridis)
library(kableExtra)
library(lubridate)
library(plotly)



# Import passcodes
MOVE_PASS <- Sys.getenv("MOVEBANK_PASSWORD")
MOVE_USE <- Sys.getenv("MOVEBANK_USERNAME")

loginStored <- movebankLogin(username=MOVE_USE, 
                             password=MOVE_PASS)

# Get animals
animals <-getMovebankAnimals(study=1573471517,login=loginStored)
# For some reason they are duplicated
animals[duplicated(animals)==F,]
# They vary by the field "sensor_type_id"
animals <- animals[animals$sensor_type_id==653,]

# Get last 2 weeks
t <- now("America/Costa_Rica")
start_t <- t-as.difftime(14,units='days')


dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE,
                       timestamp_start=start_t)

# all data
#dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE)

# Convery move stack to dataframe
dat <- as.data.frame(dat)

# Convert dat to costa rica time
dat$timestamp <- with_tz(dat$timestamp, tzone = "America/Costa_Rica")

```

*Last data request: `r now(tzone = "America/Costa_Rica")`*

The project currently contains `r length(unique(dat$tag_id))` active tag deployments (defined as being active within the last 14 days). 

```{r, include=F}
# Add the location data


dat <- left_join(dat, animals[, c("tag_id", "animalName")])
# Sort the names out

dat$animalName <- sub('\\_.*', '', dat$animalName)
# Add in the taxonomic group
dat$animalName <- paste0(dat$animalName, "_", sub('\\ .*', '', dat$taxon_canonical_name))
animals$animalName <- paste0(sub('\\_.*', '', animals$animalName), "_", sub('\\ .*', '', animals$taxon_canonical_name))

# Add a country column
dat$country <- dat$location_lat<0
dat$country[dat$country==T] <- "peru"
dat$country[dat$country==F] <- "costa_rica"
#table(dat$country)



# Costa rica

# Convert to shapefiles
dat <- dat[order(dat$animalName),]


lfc <- do.call(st_sfc,
              lapply(split(dat, dat$animalName),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(animalName=levels(factor(dat[,"animalName"])), geom=lfc))

#
#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)




sp_dat <- dat[,c("animalName",    "country", "taxon_canonical_name" )]
sp_dat <- sp_dat[duplicated(sp_dat)==F,]

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

```

**Time since last check-in**

```{r, echo=F, include=F}
# Last location and time since present
dat$diff_time <- round(as.numeric(difftime(t, dat$timestamp, units="hours")),1)

last_obs <- dat %>% group_by(animalName) %>% summarize(hours_since_fix=min(diff_time))

last_sum  <- dat %>% 
  group_by(animalName) %>%
  slice(which.max(timestamp))


tmp <- last_sum[, c("animalName","taxon_canonical_name","country", "timestamp", "diff_time")]
colnames(tmp)[colnames(tmp)=="diff_time"] <- "time_since_checkin_h"
colnames(tmp)[colnames(tmp)=="timestamp"] <- "last_timestamp"
check_in_summary <- tmp[order(tmp$country, tmp$time_since_checkin_h),]


```


```{r, echo=F, message=F, warning=F}
tmp_col <- check_in_summary$time_since_checkin_h
tmp_col[tmp_col<12]<- 12

check_in_summary[,c(1,2,3,5)] %>%
  kbl() %>%
  kable_styling()  %>%
    column_spec(4, color = "white",
              background = spec_color(tmp_col, begin=0,end = 0.7, direction=-1,
                                      option="D", scale_from = c(12,120)))


### Add additional data shown later
check_in_summary$duration <- difftime(check_in_summary$last_timestamp, start_t, "days")

### Total locations Mean eobs battery power, eobs accuracy
tmp_sum <- dat %>% group_by(animalName) %>% summarise(total_obs=n(), mean_batt=mean(eobs_battery_voltage, na.rm=T), loc_accuracy=mean(eobs_horizontal_accuracy_estimate, na.rm=T))
#colnames(dat)

check_in_summary <- left_join(check_in_summary, tmp_sum)
check_in_summary$locs_per_day <- check_in_summary$total_obs/as.numeric(check_in_summary$duration)

```

**Animals not seen for >14 days**

```{r, echo=F}
tmp2 <- animals[!(animals$animalName %in% tmp$animalName),]
tmp2$days_since_check_in<- round(as.numeric(difftime(t, tmp2$timestamp_end, units="days")),1)
tmp2 <- tmp2[order(tmp2$days_since_check_in),]
#row.names(tmp2) <- 1:nrow(tmp2)

tmp2[, c("animalName", "timestamp_end", "days_since_check_in")] %>%
  kbl() %>%
  kable_styling()

```

**Tagging summary**

The proportion of active tags by country:

```{r, echo=F}
library(plotly)

library(dplyr)

fig <- plot_ly()
# All vultures - Countries
fig %>% add_pie(data = count(check_in_summary, country), labels = ~country, values = ~n,

          name = "Country")

```

And by species:

```{r, echo=F}
fig <- plot_ly()
# All vultures - Species
fig %>% add_pie(data = count(check_in_summary, taxon_canonical_name), labels = ~taxon_canonical_name, values = ~n,

          name = "Species")

```


**Maps**

From the last 14 days:

*Costa Rica*

```{r, echo=F}
tmp_cr <- dat[dat$country=="costa_rica",]
tmp_cr_shp <- dat_shp[dat_shp$country=="costa_rica",]


# First lets choose a category to colour
tmp_cr[,"animalName"] <- factor(tmp_cr[,"animalName"])
tmp_cr_shp$animalName <- factor(tmp_cr_shp$animalName)

col.cat <- turbo(length(levels(tmp_cr[,"animalName"])))
# Add it to the dataframe
tmp_cr$colours <- col.cat[tmp_cr[,"animalName"]]
tmp_cr_shp$colours <- col.cat[tmp_cr_shp$animalName]

```

We currently have `r length(unique(tmp_cr$animalName))` vultures transmitting data in Costa Rica:

```{r, echo=F}
# New map
ids <- tmp_cr_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$Esri.WorldTopoMap, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_shp[i,], color = tmp_cr_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_cr$location_long[tmp_cr$animalName==ids[i]],
                         lat=tmp_cr$location_lat[tmp_cr$animalName==ids[i]], 
                         popup=paste(tmp_cr$timestamp[tmp_cr$animalName==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_cr$location_long[tmp_cr$animalName==ids[i]]),
                         lat=last(tmp_cr$location_lat[tmp_cr$animalName==ids[i]]), 
                         popup=paste(last(tmp_cr$timestamp[tmp_cr$animalName==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F)
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_cr_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```

Daily schedule of the tags

```{r, echo=F, warning=F, message=F}

xform <- list(categoryorder = "array",
              categoryarray = c(check_in_summary$animalName))

tmp_cr$hour <- as.numeric(substr(tmp_cr$timestamp,12,13))
tmp_cr$hour <- factor(tmp_cr$hour, levels=0:23)
tmp_cr$animalName <- as.factor(tmp_cr$animalName)
tmp_cr2 <- tmp_cr %>% group_by(animalName, hour, .drop=F) %>% summarize(obs=n())


fig <- plot_ly(tmp_cr2, x = ~hour, y = ~obs, name = tmp_cr2$animalName, type = 'scatter', mode = 'lines',split = ~animalName) 
fig <- fig %>%  layout(title = "Hourly locations",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "Number of locations"))

fig

```

*Peru*

```{r, echo=F}
tmp_peru <- dat[dat$country=="peru",]
tmp_peru_shp <- dat_shp[dat_shp$country=="peru",]


# First lets choose a category to colour
tmp_peru[,"animalName"] <- factor(tmp_peru[,"animalName"])
tmp_peru_shp$animalName <- factor(tmp_peru_shp$animalName)

col.cat <- turbo(length(levels(tmp_peru[,"animalName"])))
# Add it to the dataframe
tmp_peru$colours <- col.cat[tmp_peru[,"animalName"]]
tmp_peru_shp$colours <- col.cat[tmp_peru_shp$animalName]

```

We currently have `r length(unique(tmp_peru$animalName))` vultures transmitting data in Peru:

```{r, echo=F, eval=F}
# Old map
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$Esri.WorldTopoMap, group="OS") %>%     
  addCircleMarkers(lng=tmp_peru$location_long, lat=tmp_peru$location_lat,
                   # Colour the markers depending on the 'feature type'
                   color=tmp_peru$colours,
                   radius=3,
                   stroke=F,
                   # Add a popup of the deployment code 
                   popup=paste(tmp_peru$animalName, tmp_peru$timestamp)) %>%
  addPolylines(data=tmp_peru_shp, color = tmp_peru_shp$colours, weight = 1, smoothFactor = 0.5,
              opacity = 1.0, fillOpacity = 0.5) %>% 
  # Add a legend explaining what is going on
  addLegend("bottomright", colors = col.cat,  labels = levels(tmp_peru[,"animalName"]),
            title = "Name",
            labFormat = labelFormat(prefix = "$"),
            opacity = 1
  ) %>%
  # add a layer control box to toggle between the layers
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite"),
    options = layersControlOptions(collapsed = FALSE)
  )
m
```



```{r, echo=F}
# New map
ids <- tmp_peru_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$Esri.WorldTopoMap, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_peru_shp[i,], color = tmp_peru_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_peru$location_long[tmp_peru$animalName==ids[i]],
                         lat=tmp_peru$location_lat[tmp_peru$animalName==ids[i]], 
                         popup=paste(tmp_peru$timestamp[tmp_peru$animalName==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_peru_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_peru$location_long[tmp_peru$animalName==ids[i]]),
                         lat=last(tmp_peru$location_lat[tmp_peru$animalName==ids[i]]), 
                         popup=paste(last(tmp_peru$timestamp[tmp_peru$animalName==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_peru_shp$colours[i], group = ids[i], stroke=F)
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_peru_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```



Daily schedule of the tags:

```{r, echo=F, warning=F, message=F}

tmp_peru$hour <- as.numeric(substr(tmp_peru$timestamp,12,13))
tmp_peru$hour <- factor(tmp_peru$hour, levels=0:23)

tmp_peru$animalName <- as.factor(tmp_peru$animalName)

tmp_peru2 <- tmp_peru %>% group_by(animalName, hour, .drop=F) %>% summarize(obs=n())


fig <- plot_ly(tmp_peru2, x = ~hour, y = ~obs, name = tmp_peru2$animalName, type = 'scatter', mode = 'lines',split = ~animalName) 
fig <- fig %>%  layout(title = "Hourly locations",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "Number of locations"))

fig

```

# Last 48 Hours  {.tabset}

The following maps relate to just the last 48 hours of data. Use this to find interesting clusters and their associated coordinates. 

### Costa Rica

```{r, echo=F, message=F, warning=F}
# Subset to 48 hours
tmp_cr_48 <- dat[dat$country=="costa_rica" & dat$timestamp > max(ymd_hms(animals$timestamp_end))-48*60*60,]

# Remake shapefiles
lfc <- do.call(st_sfc,
              lapply(split(tmp_cr_48, tmp_cr_48$animalName),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_cr_48_shp <- st_sf(data.frame(animalName=levels(factor(tmp_cr_48[,"animalName"])), geom=lfc))

# add back in the metadata
tmp_cr_48_shp  <- left_join(tmp_cr_48_shp,sp_dat)


# First lets choose a category to colour
tmp_cr_48[,"animalName"] <- factor(tmp_cr_48[,"animalName"])
tmp_cr_48_shp$animalName <- factor(tmp_cr_48_shp$animalName)

col.cat <- turbo(length(levels(tmp_cr_48[,"animalName"])))
# Add it to the dataframe
tmp_cr_48$colours <- col.cat[tmp_cr_48[,"animalName"]]
tmp_cr_48_shp$colours <- col.cat[tmp_cr_48_shp$animalName]

```

We currently have `r length(unique(tmp_cr$animalName))` vultures transmitting data in Costa Rica:

```{r, echo=F}
# New map
ids <- tmp_cr_48_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$Esri.WorldTopoMap, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_48_shp[i,], color = tmp_cr_48_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_cr_48$location_long[tmp_cr_48$animalName==ids[i]],
                         lat=tmp_cr_48$location_lat[tmp_cr_48$animalName==ids[i]], 
                         popup=paste(tmp_cr_48$timestamp[tmp_cr_48$animalName==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_cr_48_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_cr_48$location_long[tmp_cr_48$animalName==ids[i]]),
                         lat=last(tmp_cr_48$location_lat[tmp_cr_48$animalName==ids[i]]), 
                         popup=paste(last(tmp_cr_48$timestamp[tmp_cr_48$animalName==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_48_shp$colours[i], group = ids[i], stroke=F)
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_cr_48_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```


### Peru

```{r, echo=F, message=F, warning=F}
# Subset to 48 hours
tmp_peru_48 <- dat[dat$country=="peru" & dat$timestamp > max(ymd_hms(animals$timestamp_end))-48*60*60,]

# Remake shapefiles
lfc <- do.call(st_sfc,
              lapply(split(tmp_peru_48, tmp_peru_48$animalName),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_peru_48_shp <- st_sf(data.frame(animalName=levels(factor(tmp_peru_48[,"animalName"])), geom=lfc))

# add back in the metadata
tmp_peru_48_shp  <- left_join(tmp_peru_48_shp,sp_dat)


# First lets choose a category to colour
tmp_peru_48[,"animalName"] <- factor(tmp_peru_48[,"animalName"])
tmp_peru_48_shp$animalName <- factor(tmp_peru_48_shp$animalName)

col.cat <- turbo(length(levels(tmp_peru_48[,"animalName"])))
# Add it to the dataframe
tmp_peru_48$colours <- col.cat[tmp_peru_48[,"animalName"]]
tmp_peru_48_shp$colours <- col.cat[tmp_peru_48_shp$animalName]

```

We currently have `r length(unique(tmp_peru$animalName))` vultures transmitting data in Costa Rica:

```{r, echo=F}
# New map
ids <- tmp_peru_48_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$Esri.WorldTopoMap, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_peru_48_shp[i,], color = tmp_peru_48_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_peru_48$location_long[tmp_peru_48$animalName==ids[i]],
                         lat=tmp_peru_48$location_lat[tmp_peru_48$animalName==ids[i]], 
                         popup=paste(tmp_peru_48$timestamp[tmp_peru_48$animalName==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_peru_48_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_peru_48$location_long[tmp_peru_48$animalName==ids[i]]),
                         lat=last(tmp_peru_48$location_lat[tmp_peru_48$animalName==ids[i]]), 
                         popup=paste(last(tmp_peru_48$timestamp[tmp_peru_48$animalName==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_peru_48_shp$colours[i], group = ids[i], stroke=F)
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_peru_48_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```


```{r, eval=F, echo=F}
library('move')
library('geodist')
library('lubridate') #version x.7.y!
library('lutz')
library('sf')
library('sp')
library('rgeos')

rFunction = function(meth="buff", rad=NULL, dur=NULL, dur_unit="days", maxgap=1, gap_unit="days", data, ...) {
  Sys.setenv(tz="UTC")
  names(data) <- make.names(names(data),allow_=FALSE)
  data@data$timestamp <- timestamps(data)
  
  if (is.null(rad))
  {
    logger.info("Your cluster radius is not supplied. We use default 200 m.")
    rad <- 200
  }
  if (is.null(dur))
  {
    logger.info(paste0("Your minimum cluster duration is not supplied. We use 14 (",dur_unit,")  as default."))
    dur <- 14
  }
  
  # take out "remove" locations from data if there are any
  remo <- FALSE
  if (any(namesIndiv(data)=="remove"))
  {
    ix <- which(namesIndiv(data)=="remove")
    remove <- data[[ix]] #move object
    data <- data[[-ix]]
    remo <- TRUE
    logger.info(paste("Your data set contains", length(remove), "locations with the ID 'remove'. Clusters close (< rad) to those locations will be removed from your results."))
    logger.info(paste("Your remaining data set has", length(data), "locations of", length(namesIndiv(data)),"individuals."))
  }

  #tried to include recurse package here to pre-filter only revisited locations, but the runtime of getRecursions() was too long
  
  # cluster for all locations (not by ID)
  coos <- coordinates(data)
  
  if (meth=="buff")
  {
    data_eq <- spTransform(data,CRSobj=paste0("+proj=aeqd +lat_0=",mean(coos[,2])," +lon_0=",mean(coos[,1])," +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"))
    data_eq_buffer <- buffer(data_eq,rad,doEdge=TRUE) #takens 20 min for 250000 locs
    data_eq_buffer_disag <- disaggregate(data_eq_buffer) #this function needs the rgeos package to work with holes in the polygons (merges overlaying buffers)
    
    pts_eq <- SpatialPoints(data_eq)
    data_eq_extr <- data.frame("point.ID"=numeric(length(pts_eq)),"poly.ID"=numeric(length(pts_eq)))
    stp <- 2000
    if (length(pts_eq)>stp)
    {
      vonbis <- matrix(c(seq(1,length(pts_eq),by=stp),(seq(1,length(pts_eq),by=stp))[-1]-1,length(pts_eq)),nc=2)
      #apply(vonbis, 1, function(x) data_eq_extr[x[1]:x[2],] <- as.data.frame(extract(data_eq_buffer_disag,pts_eq[x[1]:x[2]]))) #does not work
      for (i in seq(along=vonbis[,1])) data_eq_extr[vonbis[i,1]:vonbis[i,2],] <- extract(data_eq_buffer_disag,pts_eq[vonbis[i,1]:vonbis[i,2]])
    } else data_eq_extr[1:length(pts_eq),] <- extract(data_eq_buffer_disag,pts_eq)

    #plot(data_eq_buffer_disag,col=rainbow(26))
    #points(SpatialPoints(data_eq),col=data_eq_extr$poly.ID,pch=20,cex=5)
    memb <- data_eq_extr$poly.ID
  } else if (meth=="hclust") #cannot handle very much data, 
  {
    if(dim(coos)[1]>20000) logger.info("Your data set is likely too large for this calculation. Try the buffer method, subset your data or use less locations/individuals for the analysis.")
    
    dista <- geodist_vec(x1=coos[,1],y1=coos[,2],measure="vincenty") #unit=m, "geodesic" is probably better, but takes even longer
    
    #clu <- hclust(as.dist(dista),method="ward.D2") #measure in dendrogram is not distance
    clu <- hclust(as.dist(dista),method="average")
    #plot(as.dendrogram(clu), ylim = c(0,1000))
    #abline(h=400,col=2)
    memb <- cutree(clu,h=2*rad) #group membership for each location
  }

  memb <- as.character(memb) #changed to character for splitting possibility
  cluID_all <- unique(memb)
  data@data <- cbind(data@data,"clusterID"=memb)
  
  # split clusters with gaps larger than "maxgap" (multi-individual tracks in cluster), but careful: the timestamps were not ordered if there are more than 1 idv - now adapted!
  for (i in seq(along=cluID_all))
  {
    #print(i)
    xx <- cluID_all[i]
    ixx <- which(data@data$clusterID==xx)
    datax <- data[ixx]
    
    o <- order(timestamps(datax))
    ixo <- ixx[o]
    gapixo <- which(difftime((timestamps(datax)[o])[-1],(timestamps(datax)[o])[-length(datax)],unit=gap_unit)>maxgap)
    #gapix <- which(difftime(timestamps(datax)[-1],timestamps(datax)[-length(datax)],unit=gap_unit)>maxgap) #did not combine timestamps of multiple IDs
    if (length(gapixo)>0)
    {
      endso <- c(gapixo,length(datax))
      for (j in seq(along=gapixo)) 
      {
        ixo_endsoj <- ixo[(endso[j]+1):endso[j+1]]
        data@data$clusterID[ixo_endsoj] <- paste0(xx,".",j) #keeps orig. name for first component
      }
    }
  }
  
  cluID_all <- unique(data@data$clusterID) #feed new clusters into list of all

  #remove clusters with duration below "dur"
  cluID <- apply(matrix(cluID_all), 1, function(x) ifelse(as.numeric(difftime(max(timestamps(data)[data@data$clusterID==x]),min(timestamps(data)[data@data$clusterID==x]),unit=dur_unit))>=dur, x, NA))
  
  cluID <- cluID[!is.na(cluID)]
  
  if (length(cluID)>0) #include here to calc. number of locations/bursts not in cluster - see below
  {
    #midlon <- apply(matrix(cluID), 1, function(x) mean(coordinates(data[data@data$clusterID==x])[,1])) 
    #midlat <- apply(matrix(cluID), 1, function(x) mean(coordinates(data[data@data$clusterID==x])[,2])) 
    
    centrloc <- t(apply(matrix(cluID), 1, function(x) coordinates(data[data@data$clusterID==x])[min(which(rowMeans(geodist_vec(x1=coordinates(data[data@data$clusterID==x])[,1],y1=coordinates(data[data@data$clusterID==x])[,2],measure="vincenty"))==min(rowMeans(geodist_vec(x1=coordinates(data[data@data$clusterID==x])[,1],y1=coordinates(data[data@data$clusterID==x])[,2],measure="vincenty"))))),]))

    centrlon <- centrloc[,1]
    centrlat <- centrloc[,2]
    
    #take out clusters in rad radius around "remove"
    if (remo==TRUE) 
    {
      remo_dist <- geodist_vec(x1=coordinates(remove)[,1],y1=coordinates(remove)[,2],x2=centrlon,y2=centrlat,measure="vincenty")
      if (any(remo_dist<rad))
      {
        out <- which(remo_dist<rad,arr.ind=TRUE)[,2]
        cluID <- cluID[-out]
        centrlon <- centrlon[-out]
        centrlat <- centrlat[-out]
        logger.info(paste0(length(out)," clusters were removed from your results, because they were close (< ",rad," m) to the provided locations with ID 'remove'."))
      }
    }
    
    result <- data[data@data$clusterID %in% cluID] #these are all locations that are in a (non-remove) cluster with difftime>dur
    result@data <- result@data[,!sapply(result@data, function(x) all(is.na(x)))] #remove columns with no info
    result@data$clu.centr.long <- apply(matrix(result@data$clusterID), 1, function(x) centrlon[which(cluID==x)])
    result@data$clu.centr.lat <- apply(matrix(result@data$clusterID), 1, function(x) centrlat[which(cluID==x)])
    
    tz_info_result <- tz_lookup_coords(coordinates(result)[,2], coordinates(result)[,1], method = "accurate")
    result@data$timestamp.local <- apply(data.frame(timestamps(result),tz_info_result), 1, function(x) as.character(lubridate::with_tz(x[1], x[2])))
    result@data$local.timezone <- tz_info_result 
    result@data$date.local <- format(as.POSIXct(result@data$timestamp.local),format="%Y-%m-%d")
    result@data$time.local <- format(as.POSIXct(result@data$timestamp.local),format="%H:%M:%S")
    
    coo <- data.frame(coordinates(result))
    names(coo) <- c("location.long","location.lat")
    result.df <- data.frame(as.data.frame(result),coo) #NA columns are back in
    result.df <- result.df[,!sapply(result.df, function(x) all(is.na(x)))] #take NA out
    names(result.df) <- make.names(names(result.df),allow_=FALSE)
    clu.ix <- which(names(result.df) %in% c("clusterID","clu.centr.long","clu.centr.lat"))
    result.df <- data.frame(result.df[,clu.ix],result.df[,-clu.ix])
    heightix <- grep("height",names(result.df))
    if(length(heightix)>0) heightname <- names(result.df)[min(heightix)] else heightname <- NA
    
    #cluster table
    n.locs <- apply(matrix(cluID), 1, function(x) length(which(result@data$clusterID==x)))
    n.ids <- apply(matrix(cluID), 1, function(x) length(unique(result.df$trackId[result.df$clusterID==x])))
    id.names <- apply(matrix(cluID), 1, function(x) paste(unique(result.df$trackId[result.df$clusterID==x]),collapse=", "))
    id.tags <- apply(matrix(cluID), 1, function(x) paste(unique(result.df$tag.local.identifier[result.df$clusterID==x]),collapse=", "))
    
    # add cumlag.locs (sum of timelags of each location in cluster) - addition from Sep 2022
    result@data$timelag <- unlist(lapply(timeLag(result, units=dur_unit), function(x) c(as.vector(x), NA)))
    cumlag.locs <-  apply(matrix(cluID), 1, function(x) sum(result@data$timelag[which(result@data$clusterID==x)],na.rm=TRUE))
    
    alldata.df <- as.data.frame(data)
    
    id.locs <- id.durs <- id.locsout <- id.locsBETout <- id.nrevs <- id.durBETrevs <- id.maxdistBETrevs <- character(length(cluID))
    n.revs <- n.locsout <- numeric(length(cluID))
    for (i in seq(along=cluID))
    {
      idsi <- as.character(unique(result.df$trackId[result.df$clusterID==cluID[i]])) #individuals that use this cluster
      #if(length(idsi)>1) print(i)
      id.locs[i] <- paste(apply(matrix(idsi), 1, function(x) length(result.df$trackId[result.df$trackId==x & result.df$clusterID==cluID[i]])),collapse=", ")
      id.durs[i] <- paste(apply(matrix(idsi), 1, function(x) round(as.numeric(difftime(max(result.df$timestamp[result.df$trackId==x & result.df$clusterID==cluID[i]],na.rm=TRUE),min(result.df$timestamp[result.df$trackId==x & result.df$clusterID==cluID[i]],na.rm=TRUE),units=dur_unit)),1)),collapse=", ")
      
      id.locsout[i] <- paste(apply(matrix(idsi), 1, function(x) length(which(alldata.df$timestamp[alldata.df$trackId==x] >= min(timestamps(data[data@data$clusterID==cluID[i]])) & alldata.df$timestamp[alldata.df$trackId==x] <= max(timestamps(data[data@data$clusterID==cluID[i]])))) - length(result.df$trackId[result.df$trackId==x & result.df$clusterID==cluID[i]])),collapse=", ") #locations outside of cluster in complete cluster interval
      id.locsBETout[i] <- paste(apply(matrix(idsi), 1, function(x) length(which(alldata.df$timestamp[alldata.df$trackId==x] >= min(alldata.df$timestamp[alldata.df$clusterID==cluID[i] & alldata.df$trackId==x]) & alldata.df$timestamp[alldata.df$trackId==x] <= max(alldata.df$timestamp[alldata.df$clusterID==cluID[i] & alldata.df$trackId==x]))) - length(result.df$trackId[result.df$trackId==x & result.df$clusterID==cluID[i]])),collapse=", ") #locations outside of cluster in indiv specific cluster interval
      n.locsout[i] <- sum(as.numeric(trimws(strsplit(as.character(id.locsout[i]),",")[[1]])),na.rm=TRUE) # sum of all locations outside of cluster (all idvs. that use cluster, complete cluster duration)
      
      id.nrevisits <- id.durBETrevisits <- id.maxdistBETrevisits <- character(0)
      for (j in seq(along=idsi))
      {
        clutrackj <- alldata.df[alldata.df$trackId==idsi[j] & alldata.df$timestamp >= min(alldata.df$timestamp[alldata.df$clusterID==cluID[i] & alldata.df$trackId==idsi[j]]) & alldata.df$timestamp <= max(alldata.df$timestamp[alldata.df$clusterID==cluID[i] & alldata.df$trackId==idsi[j]]),]
        #print(clutrackj[,c("trackId","timestamp","clusterID")])
        clutr_p1 <- clutrackj[-1,]
        clutr_m1 <- clutrackj[-dim(clutrackj)[1],]

        lastix <- which(clutrackj$clusterID[-dim(clutrackj)[1]]==cluID[i] & clutr_p1$clusterID!=cluID[i]) #when leave cluster
        firstix <- which(clutrackj$clusterID[-1]==cluID[i] & clutr_m1$clusterID!=cluID[i]) +1 #when enter cluster anew
          
        #need to append with comma
        if (length(firstix)>0)
        {
          #if (length(firstix)>1) print(paste(i,j))
          id.nrevisits <- c(id.nrevisits,length(firstix))
          id.durBETrevisits <- c(id.durBETrevisits,paste(difftime(clutrackj$timestamp[firstix],clutrackj$timestamp[lastix],units="hours"),collapse=","))
          id.maxdistBETrevisits <- c(id.maxdistBETrevisits,paste(apply(matrix(seq(along=firstix)), 1, function(x) round(max(geodist_vec(x1=centrlon[i],y1=centrlat[i],x2=clutrackj$location.long[(lastix[x]+1):(firstix[x]-1)],y2=clutrackj$location.lat[(lastix[x]+1):(firstix[x]-1)])),digits=2)),collapse=","))
        } else
        {
          id.nrevisits <- c(id.nrevisits,NA)
          id.durBETrevisits <- c(id.durBETrevisits,NA)
          id.maxdistBETrevisits <- c(id.maxdistBETrevisits,NA)                
        }
        n.revs[i] <- sum(as.numeric(id.nrevisits),na.rm=TRUE) # sum of revisits (all idvs.)
        id.nrevs[i] <- paste(id.nrevisits,collapse=", ")  # number of individual revisits (zero if only once at cluster)
        id.durBETrevs[i] <- paste(id.durBETrevisits,collapse=", ") # duration outside of cluster before revisit (timediff between last loc in cluster until first loc back in cluster) - NA if no revisits
        id.maxdistBETrevs[i] <- paste(id.maxdistBETrevisits,collapse=", ") #max dist to cluster centre during gap before revisit
      }
    }
    timestamp.start <- apply(matrix(cluID), 1, function(x) paste(as.character(min(timestamps(result[result@data$clusterID==x]))),"UTC"))
    timestamp.end <- apply(matrix(cluID), 1, function(x) paste(as.character(max(timestamps(result[result@data$clusterID==x]))),"UTC"))
    duration <- as.numeric(difftime(as.POSIXct(timestamp.end), as.POSIXct(timestamp.start),units=dur_unit))
    
    cluster.diameter.m <- apply(matrix(cluID), 1, function(x) max(geodist_vec(x1=coordinates(data[data@data$clusterID==x])[,1],y1=coordinates(data[data@data$clusterID==x])[,2],measure="vincenty"),na.rm=TRUE))
    realised.centr.radius.m <- apply(matrix(cluID), 1, function(x) max(geodist_vec(x1=coordinates(data[data@data$clusterID==x])[,1],y1=coordinates(data[data@data$clusterID==x])[,2],x2=centrlon[which(cluID==x)],y2=centrlat[which(cluID==x)],measure="vincenty"),na.rm=TRUE))
    
    tz_info_clu<- tz_lookup_coords(centrlat, centrlon, method = "accurate")
    timestamp.start.local <- apply(data.frame(timestamp.start,tz_info_clu), 1, function(x) as.character(lubridate::with_tz(x[1], x[2])))
    timestamp.end.local <- apply(data.frame(timestamp.end,tz_info_clu), 1, function(x) as.character(lubridate::with_tz(x[1], x[2])))
    
    clu_tab <- data.frame("cluster.ID"=cluID,n.locs,cumlag.locs,n.ids,id.tags,id.locs,id.durs,"centr.long"=centrlon,"centr.lat"=centrlat,timestamp.start.local,timestamp.end.local,"local.timezone"=tz_info_clu,duration,timestamp.start,timestamp.end,id.names,cluster.diameter.m,realised.centr.radius.m,n.locsout,id.locsout,id.locsBETout,n.revs,id.nrevs,id.durBETrevs,id.maxdistBETrevs)
    
    names(clu_tab)[names(clu_tab)=="cumlag.locs"] <- paste0("cumlag.locs (",dur_unit,")")
    names(clu_tab)[names(clu_tab)=="duration"] <- paste0("duration (",dur_unit,")")
    names(clu_tab)[names(clu_tab)=="id.durs"] <- paste0("id.durs (",dur_unit,")")
    
    o <- order(clu_tab$n.ids,clu_tab$n.locs,decreasing=TRUE)
    clu_tab <- clu_tab[o,]
    
    write.csv(clu_tab,file=paste0(Sys.getenv(x = "APP_ARTIFACTS_DIR", "/tmp/"),"Cluster_Table.csv"),row.names=FALSE)
    #write.csv(clu_tab,file="Cluster_Table.csv",row.names=FALSE)
    
    # finish points with clusters table, add n.ids and n.locs for Email Alert App (and n.revs and n.locsout for Earth Ranger)
    result@data$n.ids <- apply(matrix(result@data$clusterID), 1, function(x) n.ids[which(cluID==x)])
    result@data$n.locs <- apply(matrix(result@data$clusterID), 1, function(x) n.locs[which(cluID==x)])
    result@data$cumlag.locs <- apply(matrix(result@data$clusterID), 1, function(x) cumlag.locs[which(cluID==x)])
    result@data$n.revs <- apply(matrix(result@data$clusterID), 1, function(x) n.revs[which(cluID==x)])
    result@data$n.locsout <- apply(matrix(result@data$clusterID), 1, function(x) n.locsout[which(cluID==x)])
    result.df <- cbind(result.df,"n.ids"=result@data$n.ids,"n.locs"=result@data$n.locs,"cumlag.locs"=result@data$cumlag.locs,"n.locsout"=result@data$n.locsout,"n.revs"=result@data$n.revs)
    
    if (!is.na(heightname))
    {
      ixcsv <- which(c("clusterID","tag.local.identifier","n.ids","n.locs","cumlag.locs","n.locsout","n.revs","timestamp.local","location.long","location.lat","date.local","time.local","local.timezone","trackId","ground.speed","heading",heightname,"clu.centr.long","clu.centr.lat") %in% names(result.df)) #fix if e.g. some data sets done have ground.speed or heading
    result.df.csv <- result.df[,c("clusterID","tag.local.identifier","n.ids","n.locs","cumlag.locs","n.locsout","n.revs","timestamp.local","location.long","location.lat","date.local","time.local","local.timezone","trackId","ground.speed","heading",heightname,"clu.centr.long","clu.centr.lat")[ixcsv]]
    } else
    {
      ixcsv <- which(c("clusterID","tag.local.identifier","n.ids","n.locs","cumlag.locs","n.locsout","n.revs","timestamp.local","location.long","location.lat","date.local","time.local","local.timezone","trackId","ground.speed","heading","clu.centr.long","clu.centr.lat") %in% names(result.df)) #fix if e.g. some data sets done have ground.speed or heading
      result.df.csv <- result.df[,c("clusterID","tag.local.identifier","n.ids","n.locs","cumlag.locs","n.locsout","n.revs","timestamp.local","location.long","location.lat","date.local","time.local","local.timezone","trackId","ground.speed","heading","clu.centr.long","clu.centr.lat")[ixcsv]]
    }
    
    names(result.df.csv)[names(result.df.csv)=="trackId"] <- c("animalID")
    names(result.df.csv)[names(result.df.csv)=="tag.local.identifier"] <- c("tagID")
    result@data$animalID <- result.df.csv$animalID
    result@data$tagID <- result.df.csv$tagID
     
    #for utm locations we would need a separate App
    
    write.csv(result.df.csv,file=paste0(Sys.getenv(x = "APP_ARTIFACTS_DIR", "/tmp/"),"Points_With_Clusters.csv"),row.names=FALSE)
    #write.csv(result.df.csv,file="Points_With_Clusters.csv",row.names=FALSE) 
    
    if (!is.na(heightname)) selnames <- c("clusterID","tagID","n.ids","n.locs","cumlag.locs","n.locsout","n.revs","timestamp.local","location.long","location.lat","date.local","time.local","local.timezone","animalID","ground.speed","heading",heightname,"clu.centr.long","clu.centr.lat")[ixcsv] else selnames <- c("clusterID","tagID","n.ids","n.locs","cumlag.locs","n.locsout","n.revs","timestamp.local","location.long","location.lat","date.local","time.local","local.timezone","animalID","ground.speed","heading","clu.centr.long","clu.centr.lat")[ixcsv]
    result@data <- data.frame(result@data,coo)
    sel <- which(names(result@data) %in% selnames)
    result@data <- data.frame(result@data[,selnames],result@data[-sel])
   
    #force moveStack if only one ID (can lead to strange error)
    if (is(result,'Move')) {
      result <- moveStack(result,forceTz="UTC")
    }
    
  } else result <- NULL
  
  # the use of package recurse or adehabitatLT does only work on tracks, but not for clusters by all animals...
  return(result)
}
```

# Hardware function and settings

The following plots track how the tags are performing in the field. 

###  Battery status
Average battery level (last 14 days):

```{r, echo=F, warning=FALSE}
cols<- c("#fc8d59", "#99d594")

fig <- plot_ly(check_in_summary, x = ~animalName, y = ~mean_batt, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Battery power",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))



fig
```


###  Location accuracy 

Average horizontal location accuracy (last 14 days):

```{r, echo=F, warning=F}
fig <- plot_ly(check_in_summary, x = ~animalName, y = ~loc_accuracy, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Location accuracy (m)",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))



fig
```


### Reporting frequencies

Average number of locations per day (last 14 days):

```{r, echo=F}
#colnames(check_in_summary)

xform <- list(categoryorder = "array",
              categoryarray = c(check_in_summary$animalName))


fig <- plot_ly(check_in_summary, x = ~animalName, y = ~locs_per_day, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Locations per day",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))


 
fig
```

### Temporal activity
*Location activity over the last 14 days*

The plot below shows a point each time we have a location at a given time.

```{r, echo=F}
library(plotly)
yform <- list(categoryorder = "array",
              categoryarray = unique(tmp_cr$animalName))


fig <- plot_ly(x = tmp_cr$timestamp, y = tmp_cr$animalName,type="scatter",
               height=1000, text=tmp_cr$animalName, hoverinfo='text',
               mode   = 'markers',
               marker = list(size = 5,
                             color = 'rgba(50, 100, 255, .2)',
                             line = list(color = 'rgba(0, 0, 0, 0)',
                                         width = 0))) %>% 
              layout(yaxis = yform)
fig

```

*Location activity over the last 14 days*

The plot below shows a point each time we have a location at a given time.

```{r, echo=F}
library(plotly)
yform <- list(categoryorder = "array",
              categoryarray = unique(tmp_peru$animalName))


fig <- plot_ly(x = tmp_peru$timestamp, y = tmp_peru$animalName,type="scatter",
               height=1000, text=tmp_peru$animalName, hoverinfo='text',
               mode   = 'markers',
               marker = list(size = 5,
                             color = 'rgba(50, 100, 255, .2)',
                             line = list(color = 'rgba(0, 0, 0, 0)',
                                         width = 0))) %>% 
              layout(yaxis = yform)
fig

```

