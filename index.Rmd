---
title: "Osa Conservation: Tracker Checker"

author:
  - Chris Beirne

site: bookdown::test-bookdown
output: bookdown::gitbook
documentclass: book
biblio-style: apalike
link-citations: yes
---

# Tracker status checker

This document summarize the movement locations for all active collars within Osa Conservation's `OC Vultures` project. 

```{r c01, echo=F, message=F, include=F}
library(rgdal)
library(move)
library(dplyr)
library(leaflet)
library(units)
library(sf)
library(viridis)
library(kableExtra)
library(lubridate)
library(plotly)
## Load packages for google drive ----
library(googledrive)
library(purrr)
library(readxl)
library(geosphere)
library(foreach)
library(maptools)

options(googledrive_quiet = TRUE)

# For when the trapping effort file is sorted
# googledrive::drive_auth(path = Sys.getenv("GOOGLE_AUTHENTICATION_CREDENTIALS"))
# 
# ## Find Google Drive folder 'Centre Circle Data & Info'
# data_folder <- drive_ls(path = "08 Databases + Analysis")
# data_path <- "data" 
# dir.create(data_path) 
# drive_download(as_id("14hLi94W4WbDn6jdXahJMnxllOgLpZh-PpIBOWqt9jlc"),
#                path="data/2_vulture_trap_deployments.xlsx")
#capture_dat <- read_excel("data/2_vulture_trap_deployments.xlsx")



# Import passcodes
MOVE_PASS <- Sys.getenv("MOVEBANK_PASSWORD")
MOVE_USE <- Sys.getenv("MOVEBANK_USERNAME")

loginStored <- movebankLogin(username=MOVE_USE, 
                             password=MOVE_PASS)

# Get animals
animals <-getMovebankAnimals(study=1573471517,login=loginStored)
# For some reason they are duplicated
animals[duplicated(animals)==F,]
# They vary by the field "sensor_type_id"
animals <- animals[animals$sensor_type_id==653,]

# Get last 2 weeks
t <- now("America/Costa_Rica")
start_t <- t-as.difftime(14,units='days')


mov_dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE,
                       timestamp_start=start_t)

# all data
#dat <- getMovebankData(study=1573471517, login=loginStored,  removeDuplicatedTimestamps=TRUE)

# Convery move stack to dataframe
dat <- as.data.frame(mov_dat)

# Convert dat to costa rica time
dat$timestamp <- with_tz(dat$timestamp, tzone = "America/Costa_Rica")

```

*Last data request: `r now(tzone = "America/Costa_Rica")`*

The project currently contains `r length(unique(dat$tag_id))` active tag deployments (defined as being active within the last 14 days). 

```{r  c02, include=F}
# Add the location data
dat <- left_join(dat, animals[, c("tag_id", "animalName")])
# Sort the names out

dat$animalName <- sub('\\_.*', '', dat$animalName)
# Add in the taxonomic group
dat$animalName <- paste0(dat$animalName, "_", sub('\\ .*', '', dat$taxon_canonical_name))
animals$animalName <- paste0(sub('\\_.*', '', animals$animalName), "_", sub('\\ .*', '', animals$taxon_canonical_name))

# Add a country column
dat$country <- dat$location_lat<0
dat$country[dat$country==T] <- "peru"
dat$country[dat$country==F] <- "costa_rica"
#table(dat$country)



# Costa rica

# Convert to shapefiles
dat <- dat[order(dat$animalName),]


lfc <- do.call(st_sfc,
              lapply(split(dat, dat$animalName),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(animalName=levels(factor(dat[,"animalName"])), geom=lfc))

#
#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)




sp_dat <- dat[,c("animalName",    "country", "taxon_canonical_name" )]
sp_dat <- sp_dat[duplicated(sp_dat)==F,]

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

```

**Time since last check-in**

```{r  c03, echo=F, include=F}
# Last location and time since present
dat$diff_time <- round(as.numeric(difftime(t, dat$timestamp, units="hours")),1)

last_obs <- dat %>% group_by(animalName) %>% summarize(hours_since_fix=min(diff_time))

last_sum  <- dat %>% 
  group_by(animalName) %>%
  slice(which.max(timestamp))


tmp <- last_sum[, c("animalName","taxon_canonical_name","country", "timestamp", "diff_time")]
colnames(tmp)[colnames(tmp)=="diff_time"] <- "time_since_checkin_h"
colnames(tmp)[colnames(tmp)=="timestamp"] <- "last_timestamp"
check_in_summary <- tmp[order(tmp$country, tmp$time_since_checkin_h),]


```


```{r  c04, echo=F, message=F, warning=F}
tmp_col <- check_in_summary$time_since_checkin_h
tmp_col[tmp_col<12]<- 12

check_in_summary[,c(1,2,3,5)] %>%
  kbl() %>%
  kable_styling()  %>%
    column_spec(4, color = "white",
              background = spec_color(tmp_col, begin=0,end = 0.7, direction=-1,
                                      option="D", scale_from = c(12,120)))


### Add additional data shown later
check_in_summary$duration <- difftime(check_in_summary$last_timestamp, start_t, "days")

### Total locations Mean eobs battery power, eobs accuracy
tmp_sum <- dat %>% group_by(animalName) %>% summarise(total_obs=n(), mean_batt=mean(eobs_battery_voltage, na.rm=T), loc_accuracy=mean(eobs_horizontal_accuracy_estimate, na.rm=T))
#colnames(dat)

check_in_summary <- left_join(check_in_summary, tmp_sum)
check_in_summary$locs_per_day <- check_in_summary$total_obs/as.numeric(check_in_summary$duration)

```

**Animals not seen for >14 days**

```{r  c05, echo=F}
tmp2 <- animals[!(animals$animalName %in% tmp$animalName),]
tmp2$timestamp_end <- with_tz(tmp2$timestamp_end, tzone = "America/Costa_Rica")
#str(tmp2)
tmp2$days_since_check_in<- round(as.numeric(difftime(t, tmp2$timestamp_end, units="days")),1)
tmp2 <- tmp2[order(tmp2$days_since_check_in),]
#row.names(tmp2) <- 1:nrow(tmp2)



tmp2[, c("animalName", "timestamp_end", "days_since_check_in")] %>%
  kbl() %>%
  kable_styling()

```

**Tagging summary**

The proportion of active tags by country:

```{r, echo=F}
library(plotly)

library(dplyr)

fig <- plot_ly()
# All vultures - Countries
fig %>% add_pie(data = count(check_in_summary, country), labels = ~country, values = ~n,

          name = "Country")

```

And by species:

```{r, echo=F}
fig <- plot_ly()
# All vultures - Species
fig %>% add_pie(data = count(check_in_summary, taxon_canonical_name), labels = ~taxon_canonical_name, values = ~n,

          name = "Species")

```


**Maps**

Last 14 days:

*Costa Rica*

```{r, echo=F}
tmp_cr <- dat[dat$country=="costa_rica",]
tmp_cr_shp <- dat_shp[dat_shp$country=="costa_rica",]


# First lets choose a category to colour
tmp_cr[,"animalName"] <- factor(tmp_cr[,"animalName"])
tmp_cr_shp$animalName <- factor(tmp_cr_shp$animalName)

col.cat <- turbo(length(levels(tmp_cr[,"animalName"])))
# Add it to the dataframe
tmp_cr$colours <- col.cat[tmp_cr[,"animalName"]]
tmp_cr_shp$colours <- col.cat[tmp_cr_shp$animalName]

```

We currently have `r length(unique(tmp_cr$animalName))` vultures transmitting data in Costa Rica:

```{r, echo=F}
# New map
ids <- tmp_cr_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_shp[i,], color = tmp_cr_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_cr$location_long[tmp_cr$animalName==ids[i]],
                         lat=tmp_cr$location_lat[tmp_cr$animalName==ids[i]], 
                         popup=paste(tmp_cr$timestamp[tmp_cr$animalName==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_cr$location_long[tmp_cr$animalName==ids[i]]),
                         lat=last(tmp_cr$location_lat[tmp_cr$animalName==ids[i]]), 
                         popup=paste(last(tmp_cr$timestamp[tmp_cr$animalName==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_shp$colours[i], group = ids[i], stroke=F)
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_cr_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```

Daily schedule of the tags

```{r, echo=F, warning=F, message=F}

xform <- list(categoryorder = "array",
              categoryarray = c(check_in_summary$animalName))

tmp_cr$hour <- as.numeric(substr(tmp_cr$timestamp,12,13))
tmp_cr$hour <- factor(tmp_cr$hour, levels=0:23)
tmp_cr$animalName <- as.factor(tmp_cr$animalName)
tmp_cr2 <- tmp_cr %>% group_by(animalName, hour, .drop=F) %>% summarize(obs=n())

# Tag activity - account for survey effort
tmp_act_cr <- tmp_cr %>% group_by(animalName, .drop=F) %>% summarize(start=min(timestamp), end=max(timestamp))

tmp_act_cr$duration <- as.numeric(difftime(tmp_act_cr$end, tmp_act_cr$start))

tmp_cr2 <- tmp_cr %>% group_by(animalName, hour, .drop=F) %>% summarize(obs=n())

tmp_cr2 <- left_join(tmp_cr2, tmp_act_cr)

tmp_cr2$sampling_rate <- tmp_cr2$obs/tmp_cr2$duration

# Add in the colour code
cols <- col.cat[1:length(levels(tmp_cr2$animalName))]


fig <- plot_ly(tmp_cr2, x = ~hour, y = ~sampling_rate, name = tmp_cr2$animalName, type = 'scatter', mode = 'lines',split = ~animalName,color=~animalName, colors=cols) 
fig <- fig %>%  layout(title = "Average hourly locations (last 14 days)",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "Locations per hour"))

fig



```

*Peru*

```{r, echo=F}
tmp_peru <- dat[dat$country=="peru",]
tmp_peru_shp <- dat_shp[dat_shp$country=="peru",]


# First lets choose a category to colour
tmp_peru[,"animalName"] <- factor(tmp_peru[,"animalName"])
tmp_peru_shp$animalName <- factor(tmp_peru_shp$animalName)

col.cat <- turbo(length(levels(tmp_peru[,"animalName"])))
# Add it to the dataframe
tmp_peru$colours <- col.cat[tmp_peru[,"animalName"]]
tmp_peru_shp$colours <- col.cat[tmp_peru_shp$animalName]

```

We currently have `r length(unique(tmp_peru$animalName))` vultures transmitting data in Peru:

```{r, echo=F, eval=F}
# Old map
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") %>%     
  addCircleMarkers(lng=tmp_peru$location_long, lat=tmp_peru$location_lat,
                   # Colour the markers depending on the 'feature type'
                   color=tmp_peru$colours,
                   radius=3,
                   stroke=F,
                   # Add a popup of the deployment code 
                   popup=paste(tmp_peru$animalName, tmp_peru$timestamp)) %>%
  addPolylines(data=tmp_peru_shp, color = tmp_peru_shp$colours, weight = 1, smoothFactor = 0.5,
              opacity = 1.0, fillOpacity = 0.5) %>% 
  # Add a legend explaining what is going on
  addLegend("bottomright", colors = col.cat,  labels = levels(tmp_peru[,"animalName"]),
            title = "Name",
            labFormat = labelFormat(prefix = "$"),
            opacity = 1
  ) %>%
  # add a layer control box to toggle between the layers
  addLayersControl(
    baseGroups = c("OS", "Simple", "Satellite"),
    options = layersControlOptions(collapsed = FALSE)
  )
m
```



```{r, echo=F}
# New map
ids <- tmp_peru_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_peru_shp[i,], color = tmp_peru_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_peru$location_long[tmp_peru$animalName==ids[i]],
                         lat=tmp_peru$location_lat[tmp_peru$animalName==ids[i]], 
                         popup=paste(tmp_peru$timestamp[tmp_peru$animalName==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_peru_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_peru$location_long[tmp_peru$animalName==ids[i]]),
                         lat=last(tmp_peru$location_lat[tmp_peru$animalName==ids[i]]), 
                         popup=paste(last(tmp_peru$timestamp[tmp_peru$animalName==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_peru_shp$colours[i], group = ids[i], stroke=F)
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_peru_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```



Daily schedule of the tags:

```{r, echo=F, warning=F, message=F}

tmp_peru$hour <- as.numeric(substr(tmp_peru$timestamp,12,13))
tmp_peru$hour <- factor(tmp_peru$hour, levels=0:23)

tmp_peru$animalName <- as.factor(tmp_peru$animalName)

tmp_peru2 <- tmp_peru %>% group_by(animalName, hour, .drop=F) %>% summarize(obs=n())


fig <- plot_ly(tmp_peru2, x = ~hour, y = ~obs, name = tmp_peru2$animalName, type = 'scatter', mode = 'lines',split = ~animalName) 
fig <- fig %>%  layout(title = "Hourly locations",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = "Number of locations"))

fig

```

# Last 48 Hours  {.tabset}

The following maps relate to just the last 48 hours of data. Use this to find interesting clusters and their associated coordinates. 

### Costa Rica

```{r, echo=F, message=F, warning=F}
# Subset to 48 hours
tmp_cr_48 <- dat[dat$country=="costa_rica" & dat$timestamp > max(ymd_hms(animals$timestamp_end))-48*60*60,]

# Remake shapefiles
lfc <- do.call(st_sfc,
              lapply(split(tmp_cr_48, tmp_cr_48$animalName),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_cr_48_shp <- st_sf(data.frame(animalName=levels(factor(tmp_cr_48[,"animalName"])), geom=lfc))

# add back in the metadata
tmp_cr_48_shp  <- left_join(tmp_cr_48_shp,sp_dat)


# First lets choose a category to colour
tmp_cr_48[,"animalName"] <- factor(tmp_cr_48[,"animalName"])
tmp_cr_48_shp$animalName <- factor(tmp_cr_48_shp$animalName)

col.cat <- turbo(length(levels(tmp_cr_48[,"animalName"])))
# Add it to the dataframe
tmp_cr_48$colours <- col.cat[tmp_cr_48[,"animalName"]]
tmp_cr_48_shp$colours <- col.cat[tmp_cr_48_shp$animalName]

```

We currently have `r length(unique(tmp_cr$animalName))` vultures transmitting data in Costa Rica:

```{r, echo=F}
# New map
ids <- tmp_cr_48_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_cr_48_shp[i,], color = tmp_cr_48_shp$colours[i], group = ids[i], weight=2,opacity=0.5)         %>%
        
        # All points
        addCircleMarkers(lng=tmp_cr_48$location_long[tmp_cr_48$animalName==ids[i]],
                         lat=tmp_cr_48$location_lat[tmp_cr_48$animalName==ids[i]], 
                         
                         popup=paste(tmp_cr_48$local_identifier[tmp_cr_48$animalName==ids[i]],
                                     "<br>Time:",tmp_cr_48$timestamp[tmp_cr_48$animalName==ids[i]],
                                     "<br>Long:",tmp_cr_48$location_long[tmp_cr_48$animalName==ids[i]],
                                     "<br>Lat:",tmp_cr_48$location_lat[tmp_cr_48$animalName==ids[i]]),
                         
                         fillOpacity = 0.3, opacity = 0.5, radius=3, color = tmp_cr_48_shp$colours[i], group = ids[i], stroke=F) %>%
        
        # The last point
        addMarkers(lng=last(tmp_cr_48$location_long[tmp_cr_48$animalName==ids[i]]),
                         lat=last(tmp_cr_48$location_lat[tmp_cr_48$animalName==ids[i]]), 
                         popup=paste(last(tmp_cr_48$local_identifier[tmp_cr_48$animalName==ids[i]]),
                                     "<br>Time:",last(tmp_cr_48$timestamp[tmp_cr_48$animalName==ids[i]]),
                                     "<br>Long:",last(tmp_cr_48$location_long[tmp_cr_48$animalName==ids[i]]),
                                     "<br>Lat:",last(tmp_cr_48$location_lat[tmp_cr_48$animalName==ids[i]]))) #, fillOpacity = 1, opacity = 1, radius=5, color = tmp_cr_48_shp$colours[i], group = ids[i], stroke=F
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_cr_48_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple", "OS", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```


### Peru

```{r, echo=F, message=F, warning=F}
# Subset to 48 hours
tmp_peru_48 <- dat[dat$country=="peru" & dat$timestamp > max(ymd_hms(animals$timestamp_end))-48*60*60,]

# Remake shapefiles
lfc <- do.call(st_sfc,
              lapply(split(tmp_peru_48, tmp_peru_48$animalName),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
tmp_peru_48_shp <- st_sf(data.frame(animalName=levels(factor(tmp_peru_48[,"animalName"])), geom=lfc))

# add back in the metadata
tmp_peru_48_shp  <- left_join(tmp_peru_48_shp,sp_dat)


# First lets choose a category to colour
tmp_peru_48[,"animalName"] <- factor(tmp_peru_48[,"animalName"])
tmp_peru_48_shp$animalName <- factor(tmp_peru_48_shp$animalName)

col.cat <- turbo(length(levels(tmp_peru_48[,"animalName"])))
# Add it to the dataframe
tmp_peru_48$colours <- col.cat[tmp_peru_48[,"animalName"]]
tmp_peru_48_shp$colours <- col.cat[tmp_peru_48_shp$animalName]

```

We currently have `r length(unique(tmp_peru$animalName))` vultures transmitting data in Costa Rica:

```{r, echo=F}
# New map
ids <- tmp_peru_48_shp$animalName
i <- 1
m <- leaflet() %>%
  # Add a satellite image layer
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     

  for (i in seq(along=ids))
    {
      m <- m %>%
        addPolylines(data = tmp_peru_48_shp[i,], color = tmp_peru_48_shp$colours[i], group = ids[i], weight=3,opacity=0.3)         %>%
        addCircleMarkers(lng=tmp_peru_48$location_long[tmp_peru_48$animalName==ids[i]],
                         lat=tmp_peru_48$location_lat[tmp_peru_48$animalName==ids[i]], 
                         popup=paste(tmp_peru_48$timestamp[tmp_peru_48$animalName==ids[i]]),
                         fillOpacity = 0.3, opacity = 0.5, radius=2, color = tmp_peru_48_shp$colours[i], group = ids[i], stroke=F) %>%
        addCircleMarkers(lng=last(tmp_peru_48$location_long[tmp_peru_48$animalName==ids[i]]),
                         lat=last(tmp_peru_48$location_lat[tmp_peru_48$animalName==ids[i]]), 
                         popup=paste(last(tmp_peru_48$timestamp[tmp_peru_48$animalName==ids[i]])),
                         fillOpacity = 1, opacity = 1, radius=5, color = tmp_peru_48_shp$colours[i], group = ids[i], stroke=F)
    }

  m <- m %>%
      addLegend(position= "topright", colors=tmp_peru_48_shp$colours, 
                labels=ids ,opacity = 0.7, title = "Animals") %>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("Simple", "OS", "Satellite"),
        overlayGroups = ids,
        options = layersControlOptions(collapsed = FALSE)
      ) 
  
m 
```

# Cluster detection

The following map shows all of the clusters which have occurred in the previous 72 hours. This map should be checked daily to find potential feeding sites for visual confirmation. The field team should:

- Prioritize recent clusters - we are more likely to find a carcass if a vulture was feeding recently
- Prioritize accessible clusters - not all of these clusters will be accessible, you should figure out which would be the easiest to visit
- Prioritise clusters with multipke individuals - if more than one individual has visited a cluster, this could suggest a large feeding event

Key:
- Colored circles denote clusters of > than 1 hour duration, where the vultures have low distances travelled
- The colors denote how recently the cluster started (Red >24 hours; orange 24-48 hours; blue 48-72 hours)
- Hover over the circle for gps coordinates, cluster radius, number of points in the cluster and duration of the event

## Costa Rica
```{r, eval=T, ech=F}
# Code derived from
# https://github.com/movestore/Daily-Rest-Sites
#library('maptools')
#library('ggmap')

# Covert timezone
mov_dat$timestamp <- with_tz(timestamps(mov_dat), tz="America/Costa_Rica")
# Subset to costa rica
sub_dat <- mov_dat[mov_dat$location_lat>0,]

# Just pull last 3 days
start_t2 <- t-as.difftime(3,units='days')
sub_dat <- sub_dat[sub_dat$timestamp>start_t2,]


sub_dat$speed <- unlist(lapply(speed(sub_dat),c, NA ))
sub_dat_df <- as.data.frame(sub_dat)
sub_dat_df <- left_join(sub_dat_df, animals[, c("tag_id", "animalName")])



sub_dat_df <- sub_dat_df[order(sub_dat_df$animalName),]
lfc <- do.call(st_sfc,
              lapply(split(sub_dat_df, sub_dat_df$animalName),
                     function(d){st_linestring(as.matrix(d[,c("location_long", "location_lat")]))}))
dat_shp <- st_sf(data.frame(animalName=levels(factor(sub_dat_df[,"animalName"])), geom=lfc))

#plot(st_geometry(dat_shp))

#
#plot(dat$location_long[dat$country=="costa_rica"], dat$location_lat[dat$country=="costa_rica"])
#plot(st_geometry(dat_shp), add=T)

# add back in the metadata
dat_shp  <- left_join(dat_shp,sp_dat)

# Bring in the colours from earlier
cr_cols <- tmp_cr[, c("animalName", "colours")]
cr_cols <- cr_cols[duplicated(cr_cols)==F,]
dat_shp <- left_join(dat_shp, cr_cols)
# Make shapefile of the tracks to add later

#plot(sub_dat_df$ground_speed, sub_dat_df$speed)
#plot(sub_dat_df$ground_speed, sub_dat_df$height_above_ellipsoid)

#plot(sub_dat, col=as.numeric(sub_dat$ground_speed<1)+1)
#plot(sub_dat[sub_dat$ground_speed<1,], add=T)



# Specifiy the settings

data=sub_dat
window="all"
upX=0
downX=0
speedvar="speed"
maxspeed=0.2

duration=1.2
radius=50


#rFunction <- function(data, window="all", upX=0, downX=0, speedvar="speed", maxspeed=NULL, duration=NULL, radius=NULL)
#{
  Sys.setenv(tz="America/Costa_Rica")
  
  names(data) <- make.names(names(data),allow_=FALSE)
  
  # add species info
  data.df <- as.data.frame(data)
  names(data.df) <- make.names(names(data.df),allow_=FALSE)
  if (any(names(data.df)=="individual.taxon.canonical.name")) data@data$species <- data.df$individual.taxon.canonical.name
  if (any(names(data.df)=="taxon.canonical.name")) data@data$species <- data.df$taxon.canonical.name
  
  speedx <- function(x) #input move object
  {
    N <- length(x)
    distVincentyEllipsoid(coordinates(x))/as.numeric(difftime(timestamps(x)[-1],timestamps(x)[-N],units="secs"))
  }

  n.all <- length(timestamps(data))
  data <- data[!duplicated(paste0(round_date(timestamps(data), "5 mins"), trackId(data))),]
  
    data.split <- move::split(data)
    data.ground <- foreach(datai = data.split) %do% {
        if (speedvar=="speed") 
        {
          if (length(datai)>1) #cannot calculated between-loc speed if only one location, therefore keep
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
 #           logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        } else if (speedvar %in% names(datai)) 
        {
          res <- datai[datai@data[,speedvar]<maxspeed | is.na(datai@data[,speedvar]),] # this allows also NA speed to be selected
#          logger.info("Your speed variable contains NA, these are kept in the data set of rest positions.")
        } else 
        {
#          logger.info("You have not selected a viable speed variable. Therefore the fallback between location speed is calculated.")
          if (length(datai)>1)
          {
            ix <- which(speedx(datai)<maxspeed)
            res <- datai[sort(unique(c(ix,ix+1))),]#this uses the speed between positions
          } else
          {
#            logger.info("One of your tracks contains only one location, so between-location speed cannot be calculated. The location is kept in the data set, but might corrupt the results.")
            res <- datai
          }
        }
        res
    }
    names(data.ground) <- names(data.split)
    data.ground <- moveStack(data.ground[unlist(lapply(data.ground, length) > 0)])

  
    # select night or day positions (use data.ground, call it "night")
    data.ground.split <- move::split(data.ground)
    data.night <- foreach(data.groundi = data.ground.split) %do% {
      #print(namesIndiv(data.groundi))
      sunupx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunrise", POSIXct.out=TRUE))$time + upX*60
      sundownx <- data.frame(sunriset(coordinates(data.groundi), timestamps(data.groundi), direction="sunset", POSIXct.out=TRUE))$time + downX*60
      data.groundi@data <- cbind(data.groundi@data,sunupx,sundownx)

            # there are no sunup or sundown during Arctic summer, then only day positions possible "sunupdown". respectively for Arctic winter
      ix <- which(is.na(sunupx) | is.na(sundownx))
      
      ix_ArcSum <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_ArcWin <- ix[coordinates(data.groundi)[ix,2]>50 & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      ix_AntWin <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(4:8)]
      ix_AntSum <- ix[coordinates(data.groundi)[ix,2]<(-50) & as.POSIXlt(timestamps(data.groundi[ix,]))$mon %in% c(10:11,0:2)]
      
      if (window=="all")
      {
        data.nighti <- data.groundi
        year <- as.POSIXlt(timestamps(data.nighti))$year+1900
        yday <- as.POSIXlt(timestamps(data.nighti))$yday
        data.nighti@data <- cbind(data.nighti@data,year,yday)
      } else
      {
        if (window=="sundownup") #night roosts
        {
          if (length(ix_ArcSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcSum,]
          }
          if (length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntSum,]
          }
          
          if (length(ix_ArcWin)>0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) and", length(ix_AntWin), " southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin,ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin,ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin,ix_AntWin)),]
          } else if (length(ix_ArcWin)>0 & length(ix_AntWin)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcWin)),]
          } else if (length(ix_ArcWin)==0 & length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntWin),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntWin)]
            selND <- which(timestamps(data.groundi.ND)<=data.groundi.ND$sunupx | timestamps(data.groundi.ND)>=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntWin)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)<=data.groundi$sunupx | timestamps(data.groundi)>=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          ynight <- yday
          
          ixx <- which(is.na(data.nighti$sundownx))
          if (length(ixx)>0)
          {
            ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]] <- ynight[timestamps(data.nighti[-ixx])>data.nighti$sundownx[-ixx]]+1
            
            # for Arctic/Antarctic nights the night goes from midday to midday, which depends on the location..
            midday_ixx <- solarnoon(coordinates(data.nighti[ixx]),timestamps(data.nighti[ixx]),POSIXct.out=TRUE)$time
            ynight[timestamps(data.nighti[ixx])>midday_ixx] <- ynight[timestamps(data.nighti[ixx])>midday_ixx]+1
          } else ynight[timestamps(data.nighti)>data.nighti$sundownx] <- ynight[timestamps(data.nighti)>data.nighti$sundownx]+1
          
          # adapt for New Year's Eve
          year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- year[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx]+1
          ynight[as.POSIXlt(timestamps(data.nighti))$mday==31 & as.POSIXlt(timestamps(data.nighti))$mon==11 & timestamps(data.nighti)>data.nighti$sundownx] <- 0
          
          data.nighti@data <- cbind(data.nighti@data,year,yday,ynight)
        }
        
        if (window=="sunupdown") # day rests
        {
          if (length(ix_ArcWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcWin)," northern winter positions without 'day' (Nov-Mar) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_ArcWin,]
          }
          if (length(ix_AntWin)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntWin)," southern winter positions without 'day' (May-Sep) are taken out for the calculations."))
            data.groundi <- data.groundi[-ix_AntWin,]
          }
          
          if (length(ix_ArcSum)>0 & length(ix_AntSum)>0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle and below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) and", length(ix_AntSum), " southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum,ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum,ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum,ix_AntSum)),]
          } else if (length(ix_ArcSum)>0 & length(ix_AntSum)==0)
          {
 #           logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions above the Arctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_ArcSum)," northern summer positions without 'night' (May-Sep) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_ArcSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_ArcSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_ArcSum)),]
          } else if (length(ix_ArcSum)==0 & length(ix_AntSum)>0)
          {
#            logger.info(paste0("The data set of individual ",namesIndiv(data.groundi)," includes positions below the Antarctic circle, so there are no sunup or sundown events during some time of the year. The relevant ",length(ix_AntSum)," southern summer positions without 'night' (Nov-Mar) are kept in the data fully."))
            data.groundi.ND <- data.groundi[-c(ix_AntSum),]
            ix.ND <- seq(along=data.groundi)[-c(ix_AntSum)]
            selND <- which(timestamps(data.groundi.ND)>=data.groundi.ND$sunupx & timestamps(data.groundi.ND)<=data.groundi.ND$sundownx)
            data.nighti <- data.groundi[sort(c(ix.ND[selND],ix_AntSum)),]
          } else data.nighti <- data.groundi[timestamps(data.groundi)>=data.groundi$sunupx & timestamps(data.groundi)<=data.groundi$sundownx,]
          
          year <- as.POSIXlt(timestamps(data.nighti))$year+1900
          yday <- as.POSIXlt(timestamps(data.nighti))$yday
          data.nighti@data <- cbind(data.nighti@data,year,yday)
        }
      }
      return(data.nighti)
    }
    if (is(data.night,'Move')) data.night <- moveStack(data.night,forceTz="UTC") #force to movestack
    names (data.night) <- names(data.ground.split)
    data.night.nozero <- data.night[unlist(lapply(data.night, length) > 0)]
    
    if (length(data.night.nozero)==0) #number of list elements
    {
#      logger.info("Your data contain no night/day positions. No csv overview saved. Return NULL.")
      result <- NULL
    } else 
    {
      data.night <- moveStack(data.night.nozero)
      data.night.df <- as.data.frame(data.night)
      nacolx <- which(apply(data.night.df,2,function (x) all(is.na(x))))
      if (length(nacolx)>0) data.night.df.nna <- data.night.df[,-nacolx] else data.night.df.nna <- data.night.df #remove columns with all NA
      
      #write.csv(data.night.df.nna,file = paste0("data_rest_selectedTime.csv"),row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      #write.csv(data.night.df.nna,file = "data_rest_selectedTime.csv",row.names=FALSE) #csv artefakt of all ground and night (or day...) positions
      
      # save all rest positions if is rest by given definition (radius, duration), goes backwards for last night/day rest
      data.night.split <- move::split(data.night)
      
      if (window=="all")
      {
        prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      } else
      {
        if (window=="sundownup") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"ynight"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
        if (window=="sunupdown") prop.rest.df <- data.frame("local.identifier"=character(),"species"=character(),"year"=numeric(),"yday"=numeric(),"timestamp.first"=character(),"timestamp.last"=character(),"rest.mean.long"=numeric(),"rest.mean.lat"=numeric(),"rest.nposi"=numeric(),"rest.duration"=numeric(),"rest.radius"=numeric())
      }
      
      data.rest <- foreach(data.nighti = data.night.split) %do% {
#        logger.info(paste("Extracting rest sites of",namesIndiv(data.nighti)))
        data.resti.df <- data.frame(as.data.frame(moveStack(data.nighti)),coordinates(data.nighti))[0,] #empty df to fill, moveStack to keep trackId
        Nresti <- dim(data.resti.df)[2]
        names(data.resti.df)[(Nresti-1):Nresti] <- c("location.long","location.lat")
        
        year <- unique(data.nighti@data$year)
        for (k in seq(along=year))
        {
          
          data.nightik <- data.nighti[data.nighti@data$year==year[k],]
          
          if (window=="all")
          {
            night <- unique(data.nightik@data$yday)
          } else
          {
            if (window=="sundownup") night <- unique(data.nightik@data$ynight)
            if (window=="sunupdown") night <- unique(data.nightik@data$yday)
          }
          
          for (j in seq(along=night))
          {
            
            if (window=="all")
            {
              data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            } else
            {
              if (window=="sundownup") data.nightikj <- data.nightik[data.nightik@data$ynight==night[j],]
              if (window=="sunupdown") data.nightikj <- data.nightik[data.nightik@data$yday==night[j],]
            }
            
            last <- Nikj <- length(data.nightikj)
            while (last>1) # as long as first night/day position is not the last
            {
              data.nightikj <- data.nightikj[1:last,]
              backdt <- as.numeric(difftime(timestamps(data.nightikj)[last],timestamps(data.nightikj)[-c(last:Nikj)],units="hours"))
              if (length(backdt)>=1) #changed this to allow for further away position (if in radius assume not moved), allows for worse resolution data
              {
                # note that here not yet checked that duration in site complete, later
                if (any(backdt<=duration)) 
                {
                  data.sel <- data.nightikj[c(which(backdt<=duration),last),] 
                  data.rem <- data.nightikj[-c(which(backdt<=duration),last),]
                } else
                {
                  data.sel <- data.nightikj[(last-1):last,]
                  data.rem <- data.nightikj[-c((last-1):last),]
                }
                m <- colMeans(coordinates(data.sel))
                dp0 <- distVincentyEllipsoid(m,coordinates(data.sel))
                p0 <- coordinates(data.sel)[min(which(dp0==max(dp0))),]
                dp1 <- distVincentyEllipsoid(p0,coordinates(data.sel))
                p1 <- coordinates(data.sel)[min(which(dp1==max(dp1))),]
                maxdist <- distVincentyEllipsoid(p0,p1)
                
                if (maxdist<radius)
                {
                  ## check if already longer at this rest site
                  mid <- midPoint(p0,p1)
                  data.bef <- data.rem
                  if (length(data.bef)>=1)
                  {
                    dist.bef <- distVincentyEllipsoid(mid,coordinates(data.bef))
                    if (any(dist.bef>radius))
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration)[-(1:max(which(dist.bef>radius)))],which(backdt<=duration),last),]
                    } else 
                    {
                      data.selx <- data.nightikj[c(which(backdt>duration),which(backdt<=duration),last),]
                      data.remx <- data.nightikj[-c(which(backdt>duration),which(backdt<=duration),last),]
                    }
                  } else 
                  {
                    data.selx <- data.sel
                    data.remx <- data.rem
                  }
                  
                  data.selx.df <- data.frame(as.data.frame(moveStack(data.selx)),coordinates(data.selx))
                  Nselx <- dim(data.selx.df)[2]
                  names(data.selx.df)[(Nselx-1):Nselx] <- c("location.long","location.lat")
                  
                  time0 <- min(timestamps(data.selx))
                  timeE <- max(timestamps(data.selx))
                  durx <- as.numeric(difftime(timeE,time0,unit="hour"))
                  radx <- max(distVincentyEllipsoid(mid,coordinates(data.selx)))
                  
                  if (durx>=duration & radx<=radius) #added this condition to only save rest sites of given duration (if this condition is left out also rest site with shorter duration are given back)
                  {
                    data.resti.df <- rbind(data.resti.df,data.selx.df)
                    
                    if (window=="all")
                    {
                      prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species,"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    } else
                    {
                      if (window=="sundownup") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"ynight"=data.selx.df$ynight[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                      if (window=="sunupdown") prop.rest.df <- rbind(prop.rest.df,data.frame("local.identifier"=namesIndiv(data.selx),"species"=data.selx.df$species[1],"year"=data.selx.df$year[1],"yday"=data.selx.df$yday[1],"timestamp.first"=as.character(time0),"timestamp.last"=as.character(timeE),"rest.mean.long"=mid[1,1],"rest.mean.lat"=mid[1,2],"rest.nposi"=length(data.selx),"rest.duration"=durx,"rest.radius"=radx))
                    }
                  }
                  
                  #A) if only need one, i.e. the last, rest site per day/night
                  #break 
                  
                  #B) if need all rest sites (irregardless if previous rest site was saved, check for another one in the remaining data)
                  data.nightikj <- data.remx
                  last <- Nikj <- length(data.nightikj) #this can be zero, will be stop indication in while() condition
                  
                } else last <- last-1 #shift one time step
              } else last <- last-1 # shift one time step also if not enough data in previous Xh time frame
            } #while
          } #for j
        } #for k
        if (dim(data.resti.df)[1]>0) 
        {
          o <- order(data.resti.df$timestamp)
          data.resti <- move(x=data.resti.df$location.long[o],y=data.resti.df$location.lat[o],time=as.POSIXct(data.resti.df$timestamp[o]),data=data.resti.df[o,],sensor=data.resti.df$sensor[o],animal=data.resti.df$trackId[o])
        } else data.resti <- NULL
      }
      names(data.rest) <- names(data.night.split)
      data.rest.nozero <- data.rest[unlist(lapply(data.rest, length) > 0)] #remove IDs with no data
      
      if (length(data.rest.nozero)==0) 
      {
#        logger.info("Your output file contains no positions. No csv overview and plot saved. Return NULL.")
        result <- NULL
      } else 
      {
        result <- moveStack(data.rest.nozero)
        #write.csv(prop.rest.df,file = paste0("rest_overview.csv"),row.names=FALSE) #csv artefakt
        #write.csv(prop.rest.df,file = "rest_overview.csv",row.names=FALSE)
        
        
                #map <- get_map(bbox(extent(data)),source="stamen",force=TRUE)
        
        #data.df <- data.frame(coordinates(data),as.data.frame(moveStack(data)))
        #names(data.df)[1:2] <- c("location.long0","location.lat0")
        
        #out <- ggmap(map) +
        #  geom_path(data=data.df,aes(x=location.long0,y=location.lat0,group=trackId),colour="blue") +
        #  geom_point(data=prop.rest.df,aes(x=rest.mean.long,y=rest.mean.lat),colour="red",size=3)

                #ggsave(out, file = paste0("rest_sites_onTracks.pdf"))
        
        # note that all timestamps are UTC!
      }
    }
  #}
  #return(result)

clus_res <- prop.rest.df[duplicated(prop.rest.df)==F,]

# Add a colour colum
clus_age <- t-ymd_hms(clus_res$timestamp.last)
clus_res$col <- NA
clus_res$col[clus_age<24] <- "red"
clus_res$col[clus_age>24 & clus_age<48] <- "orange"
clus_res$col[clus_age>48] <- "blue"

# # Leaflet the data and add the output
# cols <- c("red", "blue")
# 
# m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat$ground_speed<1)+1]) 
# 
#  m <- leaflet() %>%
#   # Add a satellite image layer
#   addProviderTiles(providers$OpenStreetMap.Mapnik) #%>%     
# 
#  m <- m %>%
#         addCircleMarkers(lng=sub_dat_df$location_long,
#                          lat=sub_dat_df$location_lat, 
#                          popup=paste(sub_dat_df$timestamp),
#                          fillOpacity = 0.3, opacity = 0.5, radius=2, color=cols[as.numeric(sub_dat_df$speed<0.1)+1]) 
# 
# m 
#  
#    
#   m <- m %>%
#         addCircleMarkers(lng=tmp$rest.mean.long,
#                          lat=tmp$rest.mean.lat, 
#                          popup=paste("duration =",tmp$rest.duration, "npos =",tmp$rest.nposi),
#                          fillOpacity = 0.3, opacity = 0.7, radius=4, color="orange") 
# 
# m  
 
m <- leaflet() %>%
  # Add a satellite image layer  
  addProviderTiles(providers$Stamen.TonerLite, group="Simple") %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%
  addProviderTiles(providers$OpenStreetMap.Mapnik, group="OS") #%>%     
  m <- m %>%
        addPolylines(data = dat_shp, color = dat_shp$colours, weight=3,opacity=0.3, popup=dat_shp$animalName) %>% 
        addCircleMarkers(lng=clus_res$rest.mean.long,
                         lat=clus_res$rest.mean.lat, 
                         popup=paste("name"=clus_res$local.identifier, 
                                     "<br>duration =",round(clus_res$rest.duration,1), "h", 
                                     "<br>npos =",clus_res$rest.nposi, " Radius =" ,round(clus_res$rest.radius,1),"m",
                                     "<br>lon =" ,round(clus_res$rest.mean.lon,6)  , "lat =", round(clus_res$rest.mean.lat,6)) 
                                     ,
                          fillOpacity = 0.3, opacity = 0.7, radius=4, color=clus_res$col)%>%
      addScaleBar(position="topleft", 
                  options=scaleBarOptions(maxWidth = 100, metric = TRUE, imperial = FALSE, updateWhenIdle = TRUE)) %>%
      addLayersControl(
        baseGroups = c("OS", "Simple", "Satellite"),
        options = layersControlOptions(collapsed = FALSE)
      )  %>% 
    addLegend(position="topright", labels=c("<24", "24-48", "48+"), colors=c("red","orange","blue"), title="Cluster age")

  m


# Also include night'time sleep locations? Would that be useful?

# Cluster map

# - Nighttime locations
# - Last 72 hours - can we colour code --> based on recent locations 
# - Work flow
# Open cluster tab
# Identify accessible clusters
  # Gps points
  # Size of the spread
# Make sure 
# Cheris look at master protocol --> 

```


# Hardware function and settings

The following plots track how the tags are performing in the field. 

###  Battery status
Average battery level (last 14 days):

```{r, echo=F, warning=FALSE}
cols<- c("#fc8d59", "#99d594")

fig <- plot_ly(check_in_summary, x = ~animalName, y = ~mean_batt, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Battery power",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))



fig
```


###  Location accuracy 

Average horizontal location accuracy (last 14 days):

```{r, echo=F, warning=F}
fig <- plot_ly(check_in_summary, x = ~animalName, y = ~loc_accuracy, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Location accuracy (m)",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))



fig
```


### Reporting frequencies

Average number of locations per day (last 14 days):

```{r, echo=F}
#colnames(check_in_summary)

xform <- list(categoryorder = "array",
              categoryarray = c(check_in_summary$animalName))


fig <- plot_ly(check_in_summary, x = ~animalName, y = ~locs_per_day, type = 'bar',

        marker = list(color = cols[as.factor(check_in_summary$country)]),
        text=check_in_summary$country,
        hoverinfo='text')

fig <- fig %>% layout(title = "Locations per day",
                      xaxis = xform,
                      xaxis = list(title = ""),
                      yaxis = list(title = ""))


 
fig
```

### Temporal activity
*Location activity over the last 14 days*

The plot below shows a point each time we have a location at a given time.

```{r, echo=F}
library(plotly)
yform <- list(categoryorder = "array",
              categoryarray = unique(tmp_cr$animalName))


fig <- plot_ly(x = tmp_cr$timestamp, y = tmp_cr$animalName,type="scatter",
               height=1000, text=tmp_cr$animalName, hoverinfo='text',
               mode   = 'markers',
               marker = list(size = 5,
                             color = 'rgba(50, 100, 255, .2)',
                             line = list(color = 'rgba(0, 0, 0, 0)',
                                         width = 0))) %>% 
              layout(yaxis = yform)
fig

```

*Location activity over the last 14 days*

The plot below shows a point each time we have a location at a given time.

```{r, echo=F}
library(plotly)
yform <- list(categoryorder = "array",
              categoryarray = unique(tmp_peru$animalName))


fig <- plot_ly(x = tmp_peru$timestamp, y = tmp_peru$animalName,type="scatter",
               height=1000, text=tmp_peru$animalName, hoverinfo='text',
               mode   = 'markers',
               marker = list(size = 5,
                             color = 'rgba(50, 100, 255, .2)',
                             line = list(color = 'rgba(0, 0, 0, 0)',
                                         width = 0))) %>% 
              layout(yaxis = yform)
fig

```

